<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Dungeon Crawler: Character Combat</title>
    <style>
        /* Base Configuration - Applies to all themes */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            transition: background-color 0.5s, color 0.5s;
        }

        #game-container {
            width: 95%;
            max-width: 1000px; /* Made bigger */
            height: 800px;     /* Fixed height for a consistent screen size */
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all 0.5s;
        }

        /* --- THEMES --- */

        /* Default Theme: Cream/Black */
        .theme-default {
            background-color: #F0F0E0;
            color: #121212;
        }
        .theme-default #game-container {
            background-color: #FFFFFF;
            border: 2px solid #333333;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }
        .theme-default .action-button {
            background-color: #4CAF50;
            color: white;
            box-shadow: 0 4px 0 #388E3C;
        }
        .theme-default .action-button:hover { background-color: #388E3C; }
        .theme-default #combat-log, .theme-default #dialogue-box {
            background-color: #F8F8F8;
            border: 1px solid #CCCCCC;
        }
        .theme-default .stat-item span { color: #008CBA; }


        /* Dark Mode Theme: Dark Gray/Light Text */
        .theme-dark {
            background-color: #121212;
            color: #E0E0E0;
        }
        .theme-dark #game-container {
            background-color: #1C1C1C;
            border: 3px solid #3A3A3A;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }
        .theme-dark .action-button {
            background-color: #5cb85c;
            color: white;
            box-shadow: 0 4px 0 #449d44;
        }
        .theme-dark .action-button:hover { background-color: #449d44; }
        .theme-dark #combat-log, .theme-dark #dialogue-box {
            background-color: #252525;
            border: 1px solid #444444;
        }
        .theme-dark .stat-item span { color: #FFD700; }

        /* Retro Mode Theme: Black/Green Text */
        .theme-retro {
            background-color: #000000;
            color: #00FF00;
        }
        .theme-retro #game-container {
            background-color: #000000;
            border: 3px solid #00AA00;
            box-shadow: 0 0 15px #00FF00;
        }
        .theme-retro .action-button {
            background-color: #006600;
            color: #00FF00;
            border: 1px solid #00AA00;
            box-shadow: 0 4px 0 #004400;
        }
        .theme-retro .action-button:hover { background-color: #004400; }
        .theme-retro #combat-log, .theme-retro #dialogue-box {
            background-color: #000000;
            border: 1px dashed #00AA00;
        }
        .theme-retro .stat-item span { color: #00FF00; }
        .theme-retro .stat-item { filter: brightness(1.5); }
        .theme-retro * { text-shadow: 0 0 1px #00FF00; }


        /* --- UI COMPONENTS --- */

        #stat-area {
            padding: 10px 20px;
            font-weight: bold;
            font-size: 1em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: inherit; /* Border from container */
        }
        .stat-item { margin-left: 15px; }
        .stat-item span { font-weight: 800; }

        #display-area {
            flex-grow: 1; /* Takes up the remaining height */
            position: relative;
            overflow: hidden;
        }

        .game-view {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }

        .hidden { display: none !important; }

        /* Main Menu/Char Select Styles */
        .title { font-size: 2.5em; margin-bottom: 50px; font-weight: 900; }
        .choice-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 600px;
            margin: auto;
        }
        .choice-card {
            padding: 20px;
            border-radius: 8px;
            border: 1px solid;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-align: left;
        }
        .choice-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
        }

        /* --- COMBAT LAYOUT --- */
        #combat-view {
            display: grid;
            grid-template-columns: 2fr 1fr; /* Image/Dialogue + Log */
            grid-template-rows: 4fr 1fr; /* Image + Dialogue */
            gap: 15px;
            padding: 15px;
        }

        #image-animation-area {
            grid-column: 1 / 2;
            grid-row: 1 / 2;
            border-radius: 8px;
            background-color: rgba(128, 128, 128, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
        }
        
        #enemy-area { text-align: right; }
        #player-area { text-align: left; }

        #combat-dialogue-box {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.1em;
            line-height: 1.5;
            align-self: stretch;
            min-height: 70px;
        }

        #combat-log {
            grid-column: 2 / 3;
            grid-row: 1 / 3;
            padding: 10px;
            border-radius: 8px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.4;
        }
        #combat-log strong { font-weight: 800; }

        /* --- ACTION AREA (Bottom Buttons) --- */
        #action-area {
            padding: 15px 10px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            border-top: inherit;
        }
        .action-button {
            border: none;
            padding: 12px 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            border-radius: 6px;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.1s;
            min-width: 150px;
        }
        .action-button:active { transform: translateY(4px); box-shadow: none !important; }

        /* Specific ability colors */
        .ability-attack { background-color: #E65100; box-shadow: 0 4px 0 #B84500 !important; color: white; }
        .ability-attack:hover { background-color: #B84500; }
        .ability-utility { background-color: #1976D2; box-shadow: 0 4px 0 #1565C0 !important; color: white; }
        .ability-utility:hover { background-color: #1565C0; }
    </style>
</head>
<body class="theme-default">

    <div id="game-container">
        <!-- Area for persistent player stats -->
        <div id="stat-area">
            <span id="player-name">The Dungeon Crawler</span>
            <div>
                <span class="stat-item">HP: <span id="player-hp">---</span></span>
                <span class="stat-item">Gold: <span id="player-gold">0</span></span>
                <span class="stat-item">Floor: <span id="current-floor">---</span></span>
            </div>
        </div>

        <!-- MAIN DISPLAY AREA (Container for all screens) -->
        <div id="display-area">
            
            <!-- 1. MAIN MENU VIEW -->
            <div id="menu-view" class="game-view">
                <h1 class="title">The Dungeon Crawler</h1>
                <div style="display: flex; flex-direction: column; gap: 20px;">
                    <button class="action-button" style="min-width: 200px;" onclick="showCharSelect()">New Game</button>
                    <button class="action-button" style="min-width: 200px;" disabled>Load Game (Coming Soon)</button>
                    <button class="action-button" style="min-width: 200px;" onclick="showSettings()">Settings</button>
                </div>
            </div>

            <!-- 2. CHARACTER SELECT VIEW (Initially hidden) -->
            <div id="char-select-view" class="game-view hidden">
                <h1 class="title">Choose Your Champion</h1>
                <div class="choice-grid">
                    <div class="choice-card" onclick="startGame('BALTER')">
                        <h3>Balter: The Grappler</h3>
                        <p>High HP, high defense. Uses grappling moves and counter-attacks. Low speed.</p>
                        <p><em>Starting Coin Flips: 2</em></p>
                    </div>
                    <div class="choice-card" onclick="startGame('STRIKER')">
                        <h3>Striker: The Brawler</h3>
                        <p>High damage potential, momentum stacks, and forces clashes. Speed increases coins.</p>
                        <p><em>Starting Coin Flips: 1</em></p>
                    </div>
                    <div class="choice-card" onclick="startGame('SHUTENMARU')">
                        <h3>Shuten-Maru: The Speedster</h3>
                        <p>Highest speed, utility through time manipulation (Rewind) and speed buffs (Phase).</p>
                        <p><em>Starting Coin Flips: 1</em></p>
                    </div>
                    <div class="choice-card" onclick="startGame('ZECT')">
                        <h3>Zect: The Switch Hitter</h3>
                        <p>Switches between three weapons (Scythe, Trident, Hammer) to gain different bonuses.</p>
                        <p><em>Starting Coin Flips: 2</em></p>
                    </div>
                </div>
            </div>

            <!-- 3. VISUAL NOVEL VIEW (Used for Events/Shops/Game Over) -->
            <div id="vn-view" class="game-view hidden">
                <div style="width: 100%; max-width: 800px; padding: 20px; border-radius: 8px; background: rgba(0,0,0,0.1);">
                    <p id="dialogue-text" style="font-size: 1.2em;"></p>
                </div>
            </div>

            <!-- 4. COMBAT VIEW (Initially hidden) -->
            <div id="combat-view" class="game-view hidden">
                
                <div id="image-animation-area">
                    <div id="enemy-area">
                        <h2 id="enemy-name">---</h2>
                        <p id="enemy-stats"></p>
                        <div id="enemy-status-effects"></div>
                    </div>
                    <!-- This area would contain opponent and player character images/animations -->
                    <div id="player-area">
                        <!-- Player stats visible here for quick reference -->
                        <div id="player-status-effects"></div>
                    </div>
                </div>

                <div id="combat-log">Combat log starts here...</div>

                <div id="combat-dialogue-box">
                    <p id="combat-dialogue-text">Waiting for combat to begin...</p>
                </div>
            </div>

            <!-- 5. SETTINGS VIEW (Initially hidden) -->
            <div id="settings-view" class="game-view hidden">
                <h1 class="title">Settings</h1>
                <p>Choose your display theme:</p>
                <div style="display: flex; gap: 30px; margin-top: 20px;">
                    <button class="action-button" style="background: #FFFFFF; color: #121212;" onclick="applyTheme('default')">Default (Cream)</button>
                    <button class="action-button" style="background: #1C1C1C; color: #E0E0E0;" onclick="applyTheme('dark')">Dark Mode</button>
                    <button class="action-button" style="background: #000000; color: #00FF00;" onclick="applyTheme('retro')">Retro (Green)</button>
                </div>
                <button class="action-button" style="margin-top: 50px;" onclick="showMenu()">Back to Menu</button>
            </div>


        </div>
        
        <!-- ACTION AREA (Shared between views) -->
        <div id="action-area">
            <!-- Buttons generated by JS -->
        </div>
    </div>

    <script>
        // --- START game.js CONTENT ---

        // --- 1. Character Data Definitions (Initial Rosters) ---

        const CHARACTER_DATA = {
            // Player Characters
            BALTER: {
                name: "Balter",
                maxHp: 120, attack: 10, defense: 6, speed: 7, coinFlips: 2,
            },
            STRIKER: {
                name: "Striker",
                maxHp: 90, attack: 6, defense: 4, speed: 12, coinFlips: 1,
            },
            SHUTENMARU: {
                name: "Shuten-Maru",
                maxHp: 80, attack: 8, defense: 5, speed: 15, coinFlips: 1
            },
            ZECT: {
                name: "Zect",
                maxHp: 100, attack: 6, defense: 5, speed: 9, coinFlips: 2
            },

            // Enemy Example
            GOBLIN: {
                name: "Goblin Grunt", maxHp: 30, attack: 8, defense: 2, speed: 6, coinFlips: 1
            }
        };

        // --- 2. Data Structures ---

        class Character {
            constructor(data) {
                this.name = data.name;
                this.maxHp = data.maxHp;
                this.currentHp = data.maxHp;
                
                this.baseDefense = data.defense; 
                this.defense = data.defense;     
                this.baseAttack = data.attack; 
                this.attack = data.attack;

                this.baseSpeed = data.speed;
                this.speed = data.speed;

                this.baseCoinFlips = data.coinFlips;
                this.coinFlips = data.coinFlips;
                this.isAlive = true;
                
                this.status = {
                    isGrappled: false,
                    isGrappledBy: null, 
                    isStaggered: false,
                    skipperTurns: 0,
                    mistyStacks: 0,
                    momentumStacks: 0,
                    currentForm: data.name === 'Zect' ? 'Scythe' : null,
                    rewindUsed: false,
                    ironGuardActive: false,
                    tempDefenseBonus: 0,
                    tempSpeedBonus: 0,
                    zectClashBonus: 0,
                    zectScytheHeal: false,
                    strikerRounds: 0, // Now 0 at start, increments after turn 1
                    shutenDoublePalm: false,
                    lastDamageTaken: 0,
                };
            }

            // --- Core Methods ---
            
            takeDamage(damage, type = 'Physical', ignoreDefense = false) {
                let initialDamage = damage;

                // Shuten-Maru's Misty Trait Check
                if (this.name === 'Shuten-Maru' && this.status.mistyStacks > 0) {
                    initialDamage = Math.max(1, initialDamage - (this.status.mistyStacks * 2)); 
                    currentTurn.log.push(`*Shuten-Maru's Misty stack (${this.status.mistyStacks}) dissipated, lessening the impact.*`);
                    this.status.mistyStacks = 0;
                }

                let defenseValue = ignoreDefense ? 0 : this.defense;
                let effectiveDamage = Math.max(0, initialDamage - defenseValue);
                this.currentHp -= effectiveDamage;
                this.status.lastDamageTaken = effectiveDamage;

                if (this.currentHp <= 0) {
                    this.currentHp = 0;
                    this.isAlive = false;
                }

                return effectiveDamage;
            }

            rollAttackDamage(dieSize, type = 'Physical') {
                let baseDamage = 1 + Math.floor(Math.random() * dieSize);
                let bonus = 0;
                
                if (this.name === 'Striker' && type === 'Physical' && this.status.momentumStacks > 0) {
                    bonus += this.status.momentumStacks;
                }
                
                if (this.name === 'Striker' && this.status.skipperTurns > 0) {
                    if (type === 'Physical') {
                        bonus += 2;
                    }
                }

                if (this.name === 'Shuten-Maru' && currentTurn.isRewindTurn) {
                    baseDamage *= 2;
                    currentTurn.log.push(`Shuten-Maru's damage doubled due to Rewind!`);
                }

                return baseDamage + bonus;
            }

            // --- Ability Helpers (Used in resolveTurn) ---

            startDefend() {
                // This function is now only used by the ENEMY AI's DEFEND action.
                // Player defensive actions (IRONGUARD, PHASE) have their own handlers.
                this.status.tempDefenseBonus = 5;
                this.defense += 5; 
                currentTurn.log.push(`${this.name} braces for impact, gaining +5 Defense this turn.`);
            }

            endTurnCleanup() {
                this.defense = this.baseDefense; 
                this.speed = this.baseSpeed;
                
                this.status.tempDefenseBonus = 0;
                this.status.tempSpeedBonus = 0;
                this.status.ironGuardActive = false;
                this.status.isStaggered = false; 
                this.status.zectClashBonus = 0;
                this.status.zectScytheHeal = false;
                
                // Striker's Slow Start (Coin increase)
                if (this.name === 'Striker' && gameState.state === 'COMBAT') {
                    this.status.strikerRounds++;
                    // Coins = Base + (Rounds * 2). Starts at 1 + (1*2) = 3 after first cleanup
                    this.coinFlips = this.baseCoinFlips + (this.status.strikerRounds * 2); 
                }

                // Striker's Skipper Countdown
                if (this.name === 'Striker' && this.status.skipperTurns > 0) {
                    this.status.skipperTurns--;
                    if (this.status.skipperTurns === 0) {
                        this.defense = this.baseDefense;
                        // Recalculate coins to reflect base + momentum
                        this.coinFlips = this.baseCoinFlips + (this.status.strikerRounds * 2); 
                        currentTurn.log.push(`Striker's Skipper buff ends. Defense restored.`);
                    }
                }
            }
        }

        // Global Game State Object
        const gameState = {
            player: null,
            currentFloor: 0,
            currentGold: 0,
            currentEnemy: null,
            state: 'MENU', // States: 'MENU', 'CHAR_SELECT', 'SETTINGS', 'VN_EVENT', 'COMBAT', 'GAME_OVER'
            playerCharacterKey: null,
            rewindState: null, 
            currentTheme: 'default',
        };

        // Global State for the current combat turn
        let currentTurn = {
            playerAction: null, 
            enemyAction: null,
            actionPerformer: null, 
            log: [],
            isRewindTurn: false, 
            staggeredEntity: null,
        };


        // --- UI/Theme Management ---

        function applyTheme(themeName) {
            document.body.className = `theme-${themeName}`;
            gameState.currentTheme = themeName;
        }

        function showView(viewId) {
            document.querySelectorAll('.game-view').forEach(view => {
                view.classList.add('hidden');
            });
            document.getElementById(viewId).classList.remove('hidden');
        }

        function updateStatsDisplay() {
            const player = gameState.player;
            document.getElementById('current-floor').textContent = gameState.currentFloor;

            if (!player) {
                document.getElementById('player-hp').textContent = '---';
                document.getElementById('player-gold').textContent = '0';
                return;
            }

            document.getElementById('player-name').textContent = player.name;
            document.getElementById('player-hp').textContent = `${player.currentHp}/${player.maxHp}`;
            document.getElementById('player-gold').textContent = gameState.currentGold;
            
            // Update combat status display (mostly for developer clarity)
            if (gameState.state === 'COMBAT') {
                const enemy = gameState.currentEnemy;
                let playerStatusHtml = `Speed: ${player.speed} | Def: ${player.defense} | Coins: ${player.coinFlips}`;
                let enemyStatsHtml = `HP: ${enemy.currentHp}/${enemy.maxHp} | Speed: ${enemy.speed} | Def: ${enemy.defense}`;

                const playerEffects = [];
                if (player.status.skipperTurns > 0) playerEffects.push(`SKIPPER (${player.status.skipperTurns})`);
                if (player.status.momentumStacks > 0) playerEffects.push(`MOMENTUM (+${player.status.momentumStacks} Dmg)`);
                if (player.status.currentForm) playerEffects.push(player.status.currentForm.toUpperCase());
                
                if (playerEffects.length > 0) playerStatusHtml += `<br>Effects: ${playerEffects.join(' | ')}`;

                const enemyEffects = [];
                if (enemy.status.isGrappled) enemyEffects.push(`GRAPPLED by ${enemy.status.isGrappledBy.name}`);

                document.getElementById('player-status-effects').innerHTML = playerStatusHtml;
                document.getElementById('enemy-status-effects').innerHTML = enemyEffects.length > 0 ? `Effects: ${enemyEffects.join(' | ')}` : '';
                document.getElementById('enemy-name').textContent = enemy.name;
                document.getElementById('enemy-stats').innerHTML = enemyStatsHtml;
            }
        }

        function displayDialogue(text) {
            if (gameState.state === 'COMBAT') {
                document.getElementById('combat-dialogue-text').innerHTML = text;
            } else {
                 document.getElementById('dialogue-text').innerHTML = text;
            }
        }

        function clearActions() {
            document.getElementById('action-area').innerHTML = '';
        }

        // --- Game Flow Functions ---

        function showMenu() {
            gameState.state = 'MENU';
            clearActions();
            showView('menu-view');
        }

        function showCharSelect() {
            gameState.state = 'CHAR_SELECT';
            clearActions();
            showView('char-select-view');
        }
        
        function showSettings() {
            gameState.state = 'SETTINGS';
            clearActions();
            showView('settings-view');
        }

        function startGame(chosenCharacterKey) {
            gameState.playerCharacterKey = chosenCharacterKey;
            gameState.player = new Character(CHARACTER_DATA[chosenCharacterKey]);
            gameState.currentFloor = 0;
            gameState.currentGold = 0;
            gameState.state = 'VN_EVENT'; 
            gameState.player.status.strikerRounds = 0; // Reset Striker's coin growth

            updateStatsDisplay();
            displayDialogue(`A new journey begins... You chose **${gameState.player.name}**!`);
            
            clearActions();
            showView('vn-view'); 
            nextRunStage();
        }

        function nextRunStage() {
            if (gameState.state === 'COMBAT') {
                gameState.currentFloor++;
            }
            
            updateStatsDisplay();
            clearActions();
            
            const encounterType = Math.floor(Math.random() * 3);
            
            if (encounterType === 0) {
                startCombat();
            } else if (encounterType === 1) {
                startVNEvent();
            } else {
                startShop();
            }
        }

        // --- Visual Novel/Event Functions (Simplified) ---

        function startVNEvent() {
            gameState.state = 'VN_EVENT';
            showView('vn-view');
            displayDialogue("You find a hidden shrine. Do you **PRAY** for luck or **SMASH** it for loot?");
            
            const actionArea = document.getElementById('action-area');
            actionArea.innerHTML = `
                <button class="action-button ability-utility" onclick="handleVNChoice('PRAY')">Pray (+HP)</button>
                <button class="action-button ability-attack" onclick="handleVNChoice('SMASH')">Smash (+Gold)</button>
            `;
        }

        function handleVNChoice(choice) {
            if (choice === 'PRAY') {
                gameState.player.currentHp = Math.min(gameState.player.maxHp, gameState.player.currentHp + 10);
                displayDialogue("You feel invigorated. (+10 HP)");
            } else if (choice === 'SMASH') {
                gameState.currentGold += 5;
                displayDialogue("You find a few rusty coins. (+5 Gold)");
            }
            updateStatsDisplay();
            
            clearActions();
            document.getElementById('action-area').innerHTML = `<button class="action-button" onclick="nextRunStage()">Continue Deeper</button>`;
        }

        function startShop() {
            gameState.state = 'SHOP';
            showView('vn-view');
            displayDialogue("You find a dusty merchant. What would you like to buy?");
            clearActions();
            const actionArea = document.getElementById('action-area');
            actionArea.innerHTML = `
                <button class="action-button" onclick="nextRunStage()">Leave Shop</button>
            `;
        }


        // --- Combat Functions ---

        function startCombat() {
            gameState.state = 'COMBAT';
            showView('combat-view');
            
            gameState.currentEnemy = new Character(CHARACTER_DATA.GOBLIN);
            
            displayCombatOptions();
        }

        function displayCombatOptions() {
            const player = gameState.player;
            const enemy = gameState.currentEnemy;
            
            // 1. Clean up from last turn and reset stats
            player.endTurnCleanup(); 
            enemy.endTurnCleanup();
            currentTurn.isRewindTurn = false; 

            // Check for stagger 
            if (player.status.isStaggered) {
                currentTurn.log.push(`${player.name} is Staggered and cannot move this turn.`);
                handlePlayerAction('STAGGERED'); 
                return;
            }

            // 2. Update UI
            document.getElementById('combat-log').innerHTML = currentTurn.log.join('<br>');
            updateStatsDisplay();
            
            // 3. Display Player Abilities (NO GENERIC DEFEND)
            let abilitiesHTML = getPlayerAbilities(player);
            
            displayDialogue(`Your Move: **${enemy.name}** vs. **${player.name}**`);
            document.getElementById('action-area').innerHTML = abilitiesHTML;
        }

        function getPlayerAbilities(player) {
            let html = '';
            
            if (player.name === 'Balter') {
                html += `<button class="action-button ability-attack" onclick="handlePlayerAction('HAYMAKER')">Haymaker (1d10)</button>`;
                html += `<button class="action-button ability-utility" onclick="handlePlayerAction('GRAPPLE')">Grapple (Str Check)</button>`;
                if (gameState.currentEnemy.status.isGrappled) {
                    html += `<button class="action-button ability-attack" onclick="handlePlayerAction('PILEDRIVER')">Piledriver (20 Dmg)</button>`;
                }
                // Balter's defense option
                html += `<button class="action-button ability-utility" onclick="handlePlayerAction('IRONGUARD')">Iron Guard (Counter)</button>`;
            } else if (player.name === 'Striker') {
                html += `<button class="action-button ability-attack" onclick="handlePlayerAction('DRAGONTWISTER')">Dragon Twister (1d6)</button>`;
                html += `<button class="action-button ability-utility" onclick="handlePlayerAction('SKIPPER')">Skipper (Buff)</button>`;
                html += `<button class="action-button ability-attack" onclick="handlePlayerAction('DISRUPTIVELUNGE')">Disruptive Lunge (1d4, Clash)</button>`;
                html += `<button class="action-button ability-attack" onclick="handlePlayerAction('HEAVYBLOW')">Heavy Blow (20, Stagger Self)</button>`;
            } else if (player.name === 'Shuten-Maru') {
                html += `<button class="action-button ability-attack" onclick="handlePlayerAction('GHOSTPALM')">Ghost Palm (1d8 Psychic)</button>`;
                // Shuten-Maru's defense/utility option
                html += `<button class="action-button ability-utility" onclick="handlePlayerAction('PHASE')">Phase (Misty/Speed)</button>`;
                html += `<button class="action-button ability-attack" onclick="handlePlayerAction('ACCELERATOR')">Accelerator (1d4 Force)</button>`;
                if (!player.status.rewindUsed) {
                    html += `<button class="action-button ability-utility" onclick="handlePlayerAction('REWIND')">Rewind (Once Per Combat)</button>`;
                }
            } else if (player.name === 'Zect') {
                const form = player.status.currentForm;
                const attackDesc = form === 'Scythe' ? '1d6 Dark (Heal)' : (form === 'Trident' ? '1d8 Force (Clash Bonus)' : '1d12 Physical (Def Bonus)');
                html += `<button class="action-button ability-attack" onclick="handlePlayerAction('TRI-SWORD')">Tri-Sword (${attackDesc})</button>`;
                html += `<button class="action-button ability-utility" onclick="handlePlayerAction('SWITCH')">Switch (to ${form === 'Scythe' ? 'Trident' : (form === 'Trident' ? 'Hammer' : 'Scythe')})</button>`;
            }
            
            // Option to proceed without action (e.g., if stunned, or saving a turn)
            html += `<button class="action-button" onclick="handlePlayerAction('PASS')">Pass Turn</button>`;

            return html;
        }

        function handlePlayerAction(action) {
            // Save state for potential Shuten-Maru Rewind
            gameState.rewindState = JSON.stringify({
                player: JSON.parse(JSON.stringify(gameState.player)), // Deep copy of object
                enemy: JSON.parse(JSON.stringify(gameState.currentEnemy)), // Deep copy of object
                currentLog: currentTurn.log
            });

            currentTurn.playerAction = action;
            
            if (action === 'PILEDRIVER' && !gameState.currentEnemy.status.isGrappled) {
                currentTurn.log.push("Piledriver failed: Target must be Grappled!");
                displayCombatOptions();
                return;
            }

            // 1. Enemy chooses its action (Simple AI: 70% Attack, 30% Defend)
            currentTurn.enemyAction = (Math.random() < 0.7) ? 'ATTACK' : 'DEFEND';
            
            // 2. Resolve the turn
            resolveTurn();
        }

        // --- CORE RESOLUTION LOGIC ---

        function resolveTurn() {
            const player = gameState.player;
            const enemy = gameState.currentEnemy;
            currentTurn.log = [];

            const cannotClash = player.status.isGrappled || enemy.status.isGrappled;
            const playerAttackActions = ['HAYMAKER', 'DRAGONTWISTER', 'GHOSTPALM', 'TRI-SWORD'];
            
            let isClash = !cannotClash && playerAttackActions.includes(currentTurn.playerAction) && currentTurn.enemyAction === 'ATTACK';

            if (!cannotClash && currentTurn.playerAction === 'DISRUPTIVELUNGE') {
                const playerIsSlower = player.speed < enemy.speed;
                if (playerIsSlower || currentTurn.enemyAction === 'ATTACK') { // Disruptive Lunge forces clash on enemy attack or if slower
                    isClash = true; 
                    currentTurn.log.push(`Striker's Disruptive Lunge forces a Clash!`);
                }
            }

            if (isClash) {
                runClash(player, enemy);
            } 
            else {
                const playerIsFaster = player.speed >= enemy.speed;
                
                const resolutionOrder = playerIsFaster ? 
                    [{ entity: player, action: currentTurn.playerAction, target: enemy }] :
                    [{ entity: enemy, action: currentTurn.enemyAction, target: player }];
                
                resolutionOrder.push(playerIsFaster ? 
                    { entity: enemy, action: currentTurn.enemyAction, target: player } :
                    { entity: player, action: currentTurn.playerAction, target: enemy }
                );

                for (const { entity, action, target } of resolutionOrder) {
                    if (!entity.isAlive || !target.isAlive || action === 'STAGGERED' || action === 'PASS') continue; 
                    currentTurn.actionPerformer = entity;

                    // Execute ability based on chosen action
                    if (action === 'DEFEND') { // Enemy DEFEND action
                        entity.startDefend();
                    } else if (action === 'ATTACK') { // Enemy basic attack
                        handleAttackAction(entity, target, enemy.attack, 'Physical');
                    } else if (action === 'IRONGUARD') {
                        handleIronGuard(entity);
                    } else if (action === 'HAYMAKER') {
                        handleAttackAction(entity, target, 10, 'Physical');
                    } else if (action === 'GRAPPLE') {
                        handleGrapple(entity, target);
                    } else if (action === 'PILEDRIVER') {
                        handlePiledriver(entity, target);
                    } else if (action === 'DRAGONTWISTER') {
                        handleAttackAction(entity, target, 6, 'Physical');
                    } else if (action === 'SKIPPER') {
                        handleSkipper(entity);
                    } else if (action === 'HEAVYBLOW') {
                        handleHeavyBlow(entity, target);
                    } else if (action === 'GHOSTPALM') {
                        handleGhostPalm(entity, target);
                    } else if (action === 'PHASE') {
                        handlePhase(entity);
                    } else if (action === 'ACCELERATOR') {
                        handleAccelerator(entity, target);
                    } else if (action === 'REWIND') {
                        // Rewind is handled in handlePlayerAction to restart the turn
                    } else if (action === 'TRI-SWORD') {
                        handleTriSword(entity, target);
                    } else if (action === 'SWITCH') {
                        handleSwitch(entity);
                    }
                }

                // --- Balter's Iron Guard Counter Trait Check (Post-action) ---
                if (player.name === 'Balter' && player.status.ironGuardActive && currentTurn.enemyAction === 'ATTACK') {
                    const balterIsFaster = player.speed > enemy.speed;
                    // If Balter was NOT faster (meaning the enemy attack ran), execute counter
                    if (!balterIsFaster) {
                        currentTurn.log.push(`Balter's Iron Guard triggers a free Haymaker counter!`);
                        handleAttackAction(player, enemy, 10, 'Physical', true); 
                    }
                }
            }

            // 5. Check for End of Combat
            endTurnChecks();
        }

        // --- ABILITY IMPLEMENTATIONS ---
        
        // Balter
        function handleIronGuard(balter) {
            // Iron Guard is Balter's DEFEND action, gaining the bonus and activating the counter flag.
            balter.startDefend(); 
            balter.status.ironGuardActive = true;
        }

        function handleGrapple(grappler, target) {
            const grapplerRoll = 1 + Math.floor(Math.random() * 10);
            const targetRoll = 1 + Math.floor(Math.random() * 8); 

            if (grapplerRoll > targetRoll) {
                target.status.isGrappled = true;
                target.status.isGrappledBy = grappler;
                target.speed = Math.max(1, target.baseSpeed - 5);
                currentTurn.log.push(`**Grapple SUCCESS!** ${target.name}'s speed is reduced and all Clashes will fail.`);
            } else {
                currentTurn.log.push(`Grapple failed. ${target.name} resisted the attempt!`);
            }
        }

        function handlePiledriver(attacker, target) {
            if (!target.status.isGrappled) return; 
            const damage = 20;
            const damageTaken = target.takeDamage(damage, 'Physical', true); 
            
            target.status.isGrappled = false;
            target.status.isGrappledBy = null;
            target.speed = target.baseSpeed;

            currentTurn.log.push(`**PILEDRIVER!** ${target.name} takes ${damageTaken} damage! Grapple ends.`);
        }

        // Striker
        function handleSkipper(striker) {
            striker.status.skipperTurns = 2;
            striker.defense = Math.floor(striker.defense / 2); 
            striker.coinFlips = 99; // Set coin flips effectively high for 'always heads'
            currentTurn.log.push(`Striker activates Skipper! Defense halved, physical damage +2, and **Clashes always win** for 2 turns.`);
        }

        function handleHeavyBlow(striker, target) {
            const damage = 20;
            const damageTaken = target.takeDamage(damage, 'Physical');
            striker.status.isStaggered = true; 
            currentTurn.log.push(`Striker hits Heavy Blow for ${damageTaken} damage! Striker is **STAGGERED** next turn.`);
        }

        // Shuten-Maru
        function handleGhostPalm(shuten, target) {
            const damage = shuten.rollAttackDamage(8, 'Psychic'); 
            const damageTaken = target.takeDamage(damage, 'Psychic');

            // Chrono-Fist Trait Check: If max damage rolled
            if (damage === 8) { 
                const heal = 5; 
                shuten.currentHp = Math.min(shuten.maxHp, shuten.currentHp + heal);
                currentTurn.log.push(`Shuten-Maru's Chrono-Fist triggers! He heals for ${heal}.`);
            }

            // Accelerator Follow-up
            if (shuten.status.shutenDoublePalm) {
                 const bonusDmg = shuten.rollAttackDamage(8, 'Psychic');
                 const bonusTaken = target.takeDamage(bonusDmg, 'Psychic');
                 currentTurn.log.push(`**Double Palm!** Follow-up hit for ${bonusTaken} Psychic damage.`);
                 shuten.status.shutenDoublePalm = false;
            }

            currentTurn.log.push(`Shuten-Maru strikes with Ghost Palm for ${damageTaken} Psychic damage.`);
        }

        function handlePhase(shuten) {
            const speedIncrease = 15; 
            shuten.status.tempSpeedBonus = speedIncrease;
            shuten.speed += speedIncrease;
            
            if (shuten.status.mistyStacks < 3) shuten.status.mistyStacks++;
            
            currentTurn.log.push(`Shuten-Maru phases! Speed greatly increased. Gains 1 stack of Misty (${shuten.status.mistyStacks}).`);
        }

        function handleAccelerator(shuten, target) {
            const damage = shuten.rollAttackDamage(4, 'Force'); 
            const shutenIsFaster = shuten.speed > target.speed;

            let damageTaken;
            if (shutenIsFaster) {
                damageTaken = target.takeDamage(damage, 'Force', true); 
                currentTurn.log.push(`Shuten-Maru is faster! Accelerator bypasses all defense for ${damageTaken} Force damage.`);

                if (currentTurn.enemyAction === 'ATTACK') {
                    shuten.status.shutenDoublePalm = true;
                    currentTurn.log.push(`Ghost Palm ready to hit twice next time!`);
                }
            } else {
                 damageTaken = target.takeDamage(damage, 'Force');
                 currentTurn.log.push(`Accelerator hits for ${damageTaken} Force damage (Defended).`);
            }
        }
        
        function handleRewind(shuten) {
            if (shuten.status.rewindUsed) return false;
            
            try {
                const oldState = JSON.parse(gameState.rewindState);

                // Restore state (NOTE: This is a deep copy restore)
                Object.assign(shuten, oldState.player);
                Object.assign(shuten.status, oldState.player.status);
                Object.assign(gameState.currentEnemy, oldState.enemy);
                Object.assign(gameState.currentEnemy.status, oldState.enemy.status);
                currentTurn.log = oldState.currentLog;

                shuten.status.rewindUsed = true;
                currentTurn.isRewindTurn = true;
                
                // Gain drastic speed for this turn (must be set before re-prompting action)
                const speedIncrease = 20;
                shuten.status.tempSpeedBonus = speedIncrease;
                shuten.speed += speedIncrease;

                currentTurn.log.push(`**REWIND SUCCESS!** Actions undone. Shuten-Maru gains drastic speed and doubled damage this turn.`);
                
                displayCombatOptions(); 
                return true; 
            } catch (e) {
                console.error("Rewind failed:", e);
                shuten.status.rewindUsed = true;
                currentTurn.log.push(`Rewind failed due to state error.`);
                return false;
            }
        }

        // Zect
        function handleTriSword(zect, target) {
            const form = zect.status.currentForm;
            let dieSize, type;

            if (form === 'Scythe') { dieSize = 6; type = 'Dark'; }
            else if (form === 'Trident') { dieSize = 8; type = 'Force'; }
            else { dieSize = 12; type = 'Physical'; }

            const damage = zect.rollAttackDamage(dieSize, type);
            const damageTaken = target.takeDamage(damage, type);

            // Scythe Form Heal Bonus
            if (form === 'Scythe' && damageTaken > 0) {
                const heal = Math.ceil(damageTaken / 2); // Heals for half damage dealt
                zect.currentHp = Math.min(zect.maxHp, zect.currentHp + heal);
                currentTurn.log.push(`Zect's Scythe Form: Heals for ${heal} HP.`);
            }

            currentTurn.log.push(`Zect attacks with ${form} for ${damageTaken} ${type} damage.`);
        }

        function handleSwitch(zect) {
            const current = zect.status.currentForm;
            let next, bonusMsg = "";

            // Reset Hammer defense bonus if switching away from it
            if (current === 'Hammer') {
                zect.baseDefense -= 1;
                zect.defense -= 1;
            }

            if (current === 'Scythe') {
                next = 'Trident';
                zect.status.zectClashBonus = 2; // Bonus applied to next Clash
                bonusMsg = "Gains +2 damage to the next CLASH.";
            } else if (current === 'Trident') {
                next = 'Hammer';
                zect.baseDefense += 1; // Permanent until next switch
                zect.defense += 1;
                bonusMsg = "Gains +1 Defense (permanent until next Switch).";
            } else { // Hammer
                next = 'Scythe';
                bonusMsg = "Next attack heals Zect for half damage dealt.";
            }

            zect.status.currentForm = next;
            currentTurn.log.push(`Zect switches to **${next} Form**! ${bonusMsg}`);
        }
        
        // --- Shared Combat Logic ---

        function handleAttackAction(attacker, defender, dieSize, type, isFreeAttack = false) {
            const defenderAction = (defender === gameState.player) ? currentTurn.playerAction : currentTurn.enemyAction;
            const defenderIsFaster = defender.speed > attacker.speed;
            
            // Speed-Block Logic (Only works against simple enemy DEFEND or if the player used an explicit defensive move that runs faster)
            if (defenderAction === 'DEFEND' && defenderIsFaster && !isFreeAttack) {
                currentTurn.log.push(`*${defender.name} is faster and successfully defended!* The attack misses.`);
                return;
            }

            let baseDamage = attacker.rollAttackDamage(dieSize, type);
            let damageTaken = defender.takeDamage(baseDamage, type);
            
            currentTurn.log.push(`${attacker.name} attacks ${defender.name} (${type}) for **${damageTaken}** damage!`);
            
            // Striker Momentum Trait Cleanup
            if (attacker.name === 'Striker' && type === 'Physical') {
                attacker.status.momentumStacks = 0;
            }
        }


        function flipCoins(numCoins, entity) {
            let heads = 0;
            if (entity.name === 'Striker' && entity.status.skipperTurns > 0) {
                heads = numCoins; // Skipper: Always Heads
            } else {
                for (let i = 0; i < numCoins; i++) {
                    if (Math.random() >= 0.5) { heads++; }
                }
            }
            return heads;
        }

        function runClash(p1, p2) {
            if (p1.status.isGrappled || p2.status.isGrappled) {
                const grappledEntity = p1.status.isGrappled ? p1 : p2;
                const winner = grappledEntity === p1 ? p2 : p1;
                currentTurn.log.push(`The Clash is nullified! **${grappledEntity.name}** fails. ${winner.name} gets a free attack.`);
                handleAttackAction(winner, grappledEntity, winner.attack, 'Physical', true); 
                return;
            }
            
            let p1Coins = p1.coinFlips;
            let p2Coins = p2.coinFlips;
            
            // Zect's Homogenous Trait
            if (p1.name === 'Zect') p1Coins *= 2;
            if (p2.name === 'Zect') p2Coins *= 2;
            
            let p1Heads = flipCoins(p1Coins, p1);
            let p2Heads = flipCoins(p2Coins, p2);
            
            currentTurn.log.push(`***CLASH!***`);
            currentTurn.log.push(`${p1.name}: ${p1Heads} Heads (of ${p1Coins} coins).`);
            currentTurn.log.push(`${p2.name}: ${p2Heads} Heads (of ${p2Coins} coins).`);

            let winner, loser;
            if (p1Heads > p2Heads) { winner = p1; loser = p2; } 
            else if (p2Heads > p1Heads) { winner = p2; loser = p1; } 
            else {
                let p1Taken = p1.takeDamage(p2.rollAttackDamage(p2.attack));
                let p2Taken = p2.takeDamage(p1.rollAttackDamage(p1.attack));
                currentTurn.log.push(`The clash is a DRAW! Both take damage.`);
                return;
            }

            let winnerHeads = (winner === p1) ? p1Heads : p2Heads;
            let bonusDamage = winnerHeads * 2;
            
            if (winner.name === 'Zect') bonusDamage *= 2;
            bonusDamage += winner.status.zectClashBonus;

            let baseDamage = winner.rollAttackDamage(winner.attack);
            let totalDamage = baseDamage + bonusDamage;
            let damageTaken = loser.takeDamage(totalDamage);
            
            currentTurn.log.push(`**${winner.name} WINS** the clash! Hits for **${damageTaken}** damage.`);

            // --- Winner Traits ---
            if (winner.name === 'Balter') {
                const extraDie = loser.status.isGrappled ? 6 : 4;
                const extraDmg = 1 + Math.floor(Math.random() * extraDie);
                const dmgTaken = loser.takeDamage(extraDmg, 'Physical', true);
                currentTurn.log.push(`Balter's Old One-Two! Extra hit for ${dmgTaken} damage.`);
            }
            
            if (winner.name === 'Striker') {
                if (winner.status.momentumStacks < 3) winner.status.momentumStacks++;
                currentTurn.log.push(`Striker gains a stack of Momentum (${winner.status.momentumStacks}).`);
            }
        }


        function endTurnChecks() {
            const player = gameState.player;
            const enemy = gameState.currentEnemy;
            
            document.getElementById('combat-log').innerHTML = currentTurn.log.join('<br>');
            
            if (!player.isAlive) {
                gameState.state = 'GAME_OVER';
                clearActions();
                displayDialogue(currentTurn.log.join('<br>') + `<br><br>Game Over. You perished on Floor ${gameState.currentFloor}!`);
                document.getElementById('action-area').innerHTML = `<button class="action-button" onclick="startGame('${gameState.playerCharacterKey}')">Try Again?</button>`;
                showView('vn-view');
            } else if (!enemy.isAlive) {
                gameState.currentGold += 10;
                displayDialogue(currentTurn.log.join('<br>') + `<br><br>**VICTORY!** The ${enemy.name} is defeated! You gained 10 Gold.`);
                clearActions();
                document.getElementById('action-area').innerHTML = `<button class="action-button" onclick="nextRunStage()">Continue Deeper</button>`;
                showView('vn-view');
            } else {
                // Combat continues
                document.getElementById('action-area').innerHTML = `<button class="action-button" onclick="displayCombatOptions()">End Turn & Continue</button>`;
            }
            
            updateStatsDisplay();
        }

        // --- Initialization ---
        window.onload = () => {
            // Start the game on the main menu screen
            showMenu();
            // Ensure stats are updated for the initial view
            updateStatsDisplay(); 
        };
        // --- END game.js CONTENT ---
    </script>
</body>
</html>
